{"ast":null,"code":"import _defineProperty from\"/Users/ivopascoal/Desktop/Naughty/naughty_front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _toConsumableArray from\"/Users/ivopascoal/Desktop/Naughty/naughty_front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _regeneratorRuntime from\"/Users/ivopascoal/Desktop/Naughty/naughty_front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _objectSpread from\"/Users/ivopascoal/Desktop/Naughty/naughty_front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _asyncToGenerator from\"/Users/ivopascoal/Desktop/Naughty/naughty_front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Users/ivopascoal/Desktop/Naughty/naughty_front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React,{createContext,useEffect,useRef,useState}from'react';import{useWallet}from'@binance-chain/bsc-use-wallet';import useBlock from'hooks/useBlock';import rabbitmintingfarm from'config/abi/rabbitmintingfarm.json';import{RABBIT_MINTING_FARM_ADDRESS}from'config/constants/nfts';import multicall from'utils/multicall';import{getPancakeRabbitContract}from'../utils/contracts';import{jsx as _jsx}from\"react/jsx-runtime\";export var NftProviderContext=/*#__PURE__*/createContext(null);var NftProvider=function NftProvider(_ref){var children=_ref.children;var isMounted=useRef(true);var _useState=useState({isInitialized:false,canClaim:false,hasClaimed:false,countBunniesBurnt:0,startBlockNumber:0,endBlockNumber:0,totalSupplyDistributed:0,currentDistributedSupply:0,balanceOf:0,bunnyMap:{}}),_useState2=_slicedToArray(_useState,2),state=_useState2[0],setState=_useState2[1];var _useWallet=useWallet(),account=_useWallet.account;var currentBlock=useBlock();var isInitialized=state.isInitialized;// Static data\nuseEffect(function(){var fetchContractData=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var _yield$multicall,_yield$multicall2,startBlockNumberArr,endBlockNumberArr,countBunniesBurntArr,totalSupplyDistributedArr,currentDistributedSupplyArr,_startBlockNumberArr,startBlockNumber,_endBlockNumberArr,endBlockNumber,_countBunniesBurntArr,countBunniesBurnt,_totalSupplyDistribut,totalSupplyDistributed,_currentDistributedSu,currentDistributedSupply;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.prev=0;_context.next=3;return multicall(rabbitmintingfarm,[{address:RABBIT_MINTING_FARM_ADDRESS,name:'startBlockNumber'},{address:RABBIT_MINTING_FARM_ADDRESS,name:'endBlockNumber'},{address:RABBIT_MINTING_FARM_ADDRESS,name:'countBunniesBurnt'},{address:RABBIT_MINTING_FARM_ADDRESS,name:'totalSupplyDistributed'},{address:RABBIT_MINTING_FARM_ADDRESS,name:'currentDistributedSupply'}]);case 3:_yield$multicall=_context.sent;_yield$multicall2=_slicedToArray(_yield$multicall,5);startBlockNumberArr=_yield$multicall2[0];endBlockNumberArr=_yield$multicall2[1];countBunniesBurntArr=_yield$multicall2[2];totalSupplyDistributedArr=_yield$multicall2[3];currentDistributedSupplyArr=_yield$multicall2[4];// TODO: Figure out why these are coming back as arrays\n_startBlockNumberArr=_slicedToArray(startBlockNumberArr,1),startBlockNumber=_startBlockNumberArr[0];_endBlockNumberArr=_slicedToArray(endBlockNumberArr,1),endBlockNumber=_endBlockNumberArr[0];_countBunniesBurntArr=_slicedToArray(countBunniesBurntArr,1),countBunniesBurnt=_countBunniesBurntArr[0];_totalSupplyDistribut=_slicedToArray(totalSupplyDistributedArr,1),totalSupplyDistributed=_totalSupplyDistribut[0];_currentDistributedSu=_slicedToArray(currentDistributedSupplyArr,1),currentDistributedSupply=_currentDistributedSu[0];setState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},{isInitialized:true,countBunniesBurnt:countBunniesBurnt.toNumber(),startBlockNumber:startBlockNumber.toNumber(),endBlockNumber:endBlockNumber.toNumber(),currentDistributedSupply:currentDistributedSupply.toNumber(),totalSupplyDistributed:totalSupplyDistributed.toNumber()});});_context.next=21;break;case 18:_context.prev=18;_context.t0=_context[\"catch\"](0);console.error('an error occured',_context.t0);case 21:case\"end\":return _context.stop();}}},_callee,null,[[0,18]]);}));return function fetchContractData(){return _ref2.apply(this,arguments);};}();fetchContractData();},[isInitialized,setState]);// Data from the contract that needs an account\nuseEffect(function(){var fetchContractData=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(){var pancakeRabbitsContract,_yield$multicall3,_yield$multicall4,canClaimArr,hasClaimedArr,balanceOf,_canClaimArr,canClaim,_hasClaimedArr,hasClaimed,bunnyMap,getTokenIdAndBunnyId,tokenIdPromises,i,tokenIdsOwnedByWallet;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.prev=0;pancakeRabbitsContract=getPancakeRabbitContract();_context3.next=4;return multicall(rabbitmintingfarm,[{address:RABBIT_MINTING_FARM_ADDRESS,name:'canClaim',params:[account]},{address:RABBIT_MINTING_FARM_ADDRESS,name:'hasClaimed',params:[account]}]);case 4:_yield$multicall3=_context3.sent;_yield$multicall4=_slicedToArray(_yield$multicall3,2);canClaimArr=_yield$multicall4[0];hasClaimedArr=_yield$multicall4[1];_context3.next=10;return pancakeRabbitsContract.methods.balanceOf(account).call();case 10:balanceOf=_context3.sent;_canClaimArr=_slicedToArray(canClaimArr,1),canClaim=_canClaimArr[0];_hasClaimedArr=_slicedToArray(hasClaimedArr,1),hasClaimed=_hasClaimedArr[0];bunnyMap={};// If the \"balanceOf\" is greater than 0 then retrieve the tokenIds\n// owned by the wallet, then the bunnyId's associated with the tokenIds\nif(!(balanceOf>0)){_context3.next=22;break;}getTokenIdAndBunnyId=/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(index){var tokenId,_bunnyId;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.prev=0;_context2.next=3;return pancakeRabbitsContract.methods.tokenOfOwnerByIndex(account,index).call();case 3:tokenId=_context2.sent;_context2.next=6;return pancakeRabbitsContract.methods.getBunnyId(tokenId).call();case 6:_bunnyId=_context2.sent;return _context2.abrupt(\"return\",[parseInt(_bunnyId,10),parseInt(tokenId,10)]);case 10:_context2.prev=10;_context2.t0=_context2[\"catch\"](0);return _context2.abrupt(\"return\",null);case 13:case\"end\":return _context2.stop();}}},_callee2,null,[[0,10]]);}));return function getTokenIdAndBunnyId(_x){return _ref4.apply(this,arguments);};}();tokenIdPromises=[];for(i=0;i<balanceOf;i++){tokenIdPromises.push(getTokenIdAndBunnyId(i));}_context3.next=20;return Promise.all(tokenIdPromises);case 20:tokenIdsOwnedByWallet=_context3.sent;// While improbable a wallet can own more than one of the same bunny so the format is:\n// { [bunnyId]: [array of tokenIds] }\nbunnyMap=tokenIdsOwnedByWallet.reduce(function(accum,association){if(!association){return accum;}var _association=_slicedToArray(association,2),bunnyId=_association[0],tokenId=_association[1];return _objectSpread(_objectSpread({},accum),{},_defineProperty({},bunnyId,accum[bunnyId]?[].concat(_toConsumableArray(accum[bunnyId]),[tokenId]):[tokenId]));},{});case 22:setState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},{isInitialized:true,canClaim:canClaim,hasClaimed:hasClaimed,balanceOf:balanceOf,bunnyMap:bunnyMap});});_context3.next=28;break;case 25:_context3.prev=25;_context3.t0=_context3[\"catch\"](0);console.error('an error occured',_context3.t0);case 28:case\"end\":return _context3.stop();}}},_callee3,null,[[0,25]]);}));return function fetchContractData(){return _ref3.apply(this,arguments);};}();if(account){fetchContractData();}},[isInitialized,account,setState]);useEffect(function(){return function(){isMounted.current=false;};},[isMounted]);var canBurnNft=currentBlock<=state.endBlockNumber;var getTokenIds=function getTokenIds(bunnyId){return state.bunnyMap[bunnyId];};/**\r\n   * Allows consumers to re-fetch all data from the contract. Triggers the effects.\r\n   * For example when a transaction has been completed\r\n   */var reInitialize=function reInitialize(){// Only attempt to re-initialize if the component is still mounted\n// Transactions can take awhile so it is likely some users will navigate to another page\n// before the transaction is finished\nif(isMounted.current){setState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},{isInitialized:false});});}};return/*#__PURE__*/_jsx(NftProviderContext.Provider,{value:_objectSpread(_objectSpread({},state),{},{canBurnNft:canBurnNft,getTokenIds:getTokenIds,reInitialize:reInitialize}),children:children});};export default NftProvider;","map":{"version":3,"sources":["/Users/ivopascoal/Desktop/Naughty/naughty_front/src/views/Nft/contexts/NftProvider.tsx"],"names":["React","createContext","useEffect","useRef","useState","useWallet","useBlock","rabbitmintingfarm","RABBIT_MINTING_FARM_ADDRESS","multicall","getPancakeRabbitContract","NftProviderContext","NftProvider","children","isMounted","isInitialized","canClaim","hasClaimed","countBunniesBurnt","startBlockNumber","endBlockNumber","totalSupplyDistributed","currentDistributedSupply","balanceOf","bunnyMap","state","setState","account","currentBlock","fetchContractData","address","name","startBlockNumberArr","endBlockNumberArr","countBunniesBurntArr","totalSupplyDistributedArr","currentDistributedSupplyArr","prevState","toNumber","console","error","pancakeRabbitsContract","params","canClaimArr","hasClaimedArr","methods","call","getTokenIdAndBunnyId","index","tokenOfOwnerByIndex","tokenId","getBunnyId","bunnyId","parseInt","tokenIdPromises","i","push","Promise","all","tokenIdsOwnedByWallet","reduce","accum","association","current","canBurnNft","getTokenIds","reInitialize"],"mappings":"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","sourcesContent":["import React, { createContext, ReactNode, useEffect, useRef, useState } from 'react'\r\nimport BigNumber from 'bignumber.js'\r\nimport { useWallet } from '@binance-chain/bsc-use-wallet'\r\nimport useBlock from 'hooks/useBlock'\r\nimport rabbitmintingfarm from 'config/abi/rabbitmintingfarm.json'\r\nimport { RABBIT_MINTING_FARM_ADDRESS } from 'config/constants/nfts'\r\nimport multicall from 'utils/multicall'\r\nimport { getPancakeRabbitContract } from '../utils/contracts'\r\n\r\ninterface NftProviderProps {\r\n  children: ReactNode\r\n}\r\n\r\ntype BunnyMap = {\r\n  [key: number]: number[]\r\n}\r\n\r\ntype State = {\r\n  isInitialized: boolean\r\n  canClaim: boolean\r\n  hasClaimed: boolean\r\n  countBunniesBurnt: number\r\n  endBlockNumber: number\r\n  startBlockNumber: number\r\n  totalSupplyDistributed: number\r\n  currentDistributedSupply: number\r\n  balanceOf: number\r\n  bunnyMap: BunnyMap\r\n}\r\n\r\ntype Context = {\r\n  canBurnNft: boolean\r\n  getTokenIds: (bunnyId: number) => number[]\r\n  reInitialize: () => void\r\n} & State\r\n\r\nexport const NftProviderContext = createContext<Context | null>(null)\r\n\r\nconst NftProvider: React.FC<NftProviderProps> = ({ children }) => {\r\n  const isMounted = useRef(true)\r\n  const [state, setState] = useState<State>({\r\n    isInitialized: false,\r\n    canClaim: false,\r\n    hasClaimed: false,\r\n    countBunniesBurnt: 0,\r\n    startBlockNumber: 0,\r\n    endBlockNumber: 0,\r\n    totalSupplyDistributed: 0,\r\n    currentDistributedSupply: 0,\r\n    balanceOf: 0,\r\n    bunnyMap: {},\r\n  })\r\n  const { account } = useWallet()\r\n  const currentBlock = useBlock()\r\n\r\n  const { isInitialized } = state\r\n\r\n  // Static data\r\n  useEffect(() => {\r\n    const fetchContractData = async () => {\r\n      try {\r\n        const [\r\n          startBlockNumberArr,\r\n          endBlockNumberArr,\r\n          countBunniesBurntArr,\r\n          totalSupplyDistributedArr,\r\n          currentDistributedSupplyArr,\r\n        ] = await multicall(rabbitmintingfarm, [\r\n          { address: RABBIT_MINTING_FARM_ADDRESS, name: 'startBlockNumber' },\r\n          { address: RABBIT_MINTING_FARM_ADDRESS, name: 'endBlockNumber' },\r\n          { address: RABBIT_MINTING_FARM_ADDRESS, name: 'countBunniesBurnt' },\r\n          { address: RABBIT_MINTING_FARM_ADDRESS, name: 'totalSupplyDistributed' },\r\n          { address: RABBIT_MINTING_FARM_ADDRESS, name: 'currentDistributedSupply' },\r\n        ])\r\n\r\n        // TODO: Figure out why these are coming back as arrays\r\n        const [startBlockNumber]: [BigNumber] = startBlockNumberArr\r\n        const [endBlockNumber]: [BigNumber] = endBlockNumberArr\r\n        const [countBunniesBurnt]: [BigNumber] = countBunniesBurntArr\r\n        const [totalSupplyDistributed]: [BigNumber] = totalSupplyDistributedArr\r\n        const [currentDistributedSupply]: [BigNumber] = currentDistributedSupplyArr\r\n\r\n        setState((prevState) => ({\r\n          ...prevState,\r\n          isInitialized: true,\r\n          countBunniesBurnt: countBunniesBurnt.toNumber(),\r\n          startBlockNumber: startBlockNumber.toNumber(),\r\n          endBlockNumber: endBlockNumber.toNumber(),\r\n          currentDistributedSupply: currentDistributedSupply.toNumber(),\r\n          totalSupplyDistributed: totalSupplyDistributed.toNumber(),\r\n        }))\r\n      } catch (error) {\r\n        console.error('an error occured', error)\r\n      }\r\n    }\r\n\r\n    fetchContractData()\r\n  }, [isInitialized, setState])\r\n\r\n  // Data from the contract that needs an account\r\n  useEffect(() => {\r\n    const fetchContractData = async () => {\r\n      try {\r\n        const pancakeRabbitsContract = getPancakeRabbitContract()\r\n        const [canClaimArr, hasClaimedArr] = await multicall(rabbitmintingfarm, [\r\n          { address: RABBIT_MINTING_FARM_ADDRESS, name: 'canClaim', params: [account] },\r\n          { address: RABBIT_MINTING_FARM_ADDRESS, name: 'hasClaimed', params: [account] },\r\n        ])\r\n        const balanceOf = await pancakeRabbitsContract.methods.balanceOf(account).call()\r\n        const [canClaim]: [boolean] = canClaimArr\r\n        const [hasClaimed]: [boolean] = hasClaimedArr\r\n\r\n        let bunnyMap: BunnyMap = {}\r\n\r\n        // If the \"balanceOf\" is greater than 0 then retrieve the tokenIds\r\n        // owned by the wallet, then the bunnyId's associated with the tokenIds\r\n        if (balanceOf > 0) {\r\n          const getTokenIdAndBunnyId = async (index: number) => {\r\n            try {\r\n              const tokenId = await pancakeRabbitsContract.methods.tokenOfOwnerByIndex(account, index).call()\r\n              const bunnyId = await pancakeRabbitsContract.methods.getBunnyId(tokenId).call()\r\n\r\n              return [parseInt(bunnyId, 10), parseInt(tokenId, 10)]\r\n            } catch (error) {\r\n              return null\r\n            }\r\n          }\r\n\r\n          const tokenIdPromises = []\r\n\r\n          for (let i = 0; i < balanceOf; i++) {\r\n            tokenIdPromises.push(getTokenIdAndBunnyId(i))\r\n          }\r\n\r\n          const tokenIdsOwnedByWallet = await Promise.all(tokenIdPromises)\r\n\r\n          // While improbable a wallet can own more than one of the same bunny so the format is:\r\n          // { [bunnyId]: [array of tokenIds] }\r\n          bunnyMap = tokenIdsOwnedByWallet.reduce((accum, association) => {\r\n            if (!association) {\r\n              return accum\r\n            }\r\n\r\n            const [bunnyId, tokenId] = association\r\n\r\n            return {\r\n              ...accum,\r\n              [bunnyId]: accum[bunnyId] ? [...accum[bunnyId], tokenId] : [tokenId],\r\n            }\r\n          }, {})\r\n        }\r\n\r\n        setState((prevState) => ({\r\n          ...prevState,\r\n          isInitialized: true,\r\n          canClaim,\r\n          hasClaimed,\r\n          balanceOf,\r\n          bunnyMap,\r\n        }))\r\n      } catch (error) {\r\n        console.error('an error occured', error)\r\n      }\r\n    }\r\n\r\n    if (account) {\r\n      fetchContractData()\r\n    }\r\n  }, [isInitialized, account, setState])\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      isMounted.current = false\r\n    }\r\n  }, [isMounted])\r\n\r\n  const canBurnNft = currentBlock <= state.endBlockNumber\r\n  const getTokenIds = (bunnyId: number) => state.bunnyMap[bunnyId]\r\n\r\n  /**\r\n   * Allows consumers to re-fetch all data from the contract. Triggers the effects.\r\n   * For example when a transaction has been completed\r\n   */\r\n  const reInitialize = () => {\r\n    // Only attempt to re-initialize if the component is still mounted\r\n    // Transactions can take awhile so it is likely some users will navigate to another page\r\n    // before the transaction is finished\r\n    if (isMounted.current) {\r\n      setState((prevState) => ({ ...prevState, isInitialized: false }))\r\n    }\r\n  }\r\n\r\n  return (\r\n    <NftProviderContext.Provider value={{ ...state, canBurnNft, getTokenIds, reInitialize }}>\r\n      {children}\r\n    </NftProviderContext.Provider>\r\n  )\r\n}\r\n\r\nexport default NftProvider\r\n"]},"metadata":{},"sourceType":"module"}