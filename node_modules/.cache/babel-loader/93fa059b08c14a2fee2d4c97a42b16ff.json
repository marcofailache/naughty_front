{"ast":null,"code":"var _jsxFileName = \"/Users/ivopascoal/Desktop/Naughty/naughty_front/src/views/Nft/contexts/NftProvider.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { createContext, useEffect, useRef, useState } from 'react';\nimport { useWallet } from '@binance-chain/bsc-use-wallet';\nimport useBlock from 'hooks/useBlock';\nimport rabbitmintingfarm from 'config/abi/rabbitmintingfarm.json';\nimport { RABBIT_MINTING_FARM_ADDRESS } from 'config/constants/nfts';\nimport multicall from 'utils/multicall';\nimport { getPancakeRabbitContract } from '../utils/contracts';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const NftProviderContext = /*#__PURE__*/createContext(null);\n\nconst NftProvider = ({\n  children\n}) => {\n  _s();\n\n  const isMounted = useRef(true);\n  const [state, setState] = useState({\n    isInitialized: false,\n    canClaim: false,\n    hasClaimed: false,\n    countBunniesBurnt: 0,\n    startBlockNumber: 0,\n    endBlockNumber: 0,\n    totalSupplyDistributed: 0,\n    currentDistributedSupply: 0,\n    balanceOf: 0,\n    bunnyMap: {}\n  });\n  const {\n    account\n  } = useWallet();\n  const currentBlock = useBlock();\n  const {\n    isInitialized\n  } = state; // Static data\n\n  useEffect(() => {\n    const fetchContractData = async () => {\n      try {\n        const [startBlockNumberArr, endBlockNumberArr, countBunniesBurntArr, totalSupplyDistributedArr, currentDistributedSupplyArr] = await multicall(rabbitmintingfarm, [{\n          address: RABBIT_MINTING_FARM_ADDRESS,\n          name: 'startBlockNumber'\n        }, {\n          address: RABBIT_MINTING_FARM_ADDRESS,\n          name: 'endBlockNumber'\n        }, {\n          address: RABBIT_MINTING_FARM_ADDRESS,\n          name: 'countBunniesBurnt'\n        }, {\n          address: RABBIT_MINTING_FARM_ADDRESS,\n          name: 'totalSupplyDistributed'\n        }, {\n          address: RABBIT_MINTING_FARM_ADDRESS,\n          name: 'currentDistributedSupply'\n        }]); // TODO: Figure out why these are coming back as arrays\n\n        const [startBlockNumber] = startBlockNumberArr;\n        const [endBlockNumber] = endBlockNumberArr;\n        const [countBunniesBurnt] = countBunniesBurntArr;\n        const [totalSupplyDistributed] = totalSupplyDistributedArr;\n        const [currentDistributedSupply] = currentDistributedSupplyArr;\n        setState(prevState => ({ ...prevState,\n          isInitialized: true,\n          countBunniesBurnt: countBunniesBurnt.toNumber(),\n          startBlockNumber: startBlockNumber.toNumber(),\n          endBlockNumber: endBlockNumber.toNumber(),\n          currentDistributedSupply: currentDistributedSupply.toNumber(),\n          totalSupplyDistributed: totalSupplyDistributed.toNumber()\n        }));\n      } catch (error) {\n        console.error('an error occured', error);\n      }\n    };\n\n    fetchContractData();\n  }, [isInitialized, setState]); // Data from the contract that needs an account\n\n  useEffect(() => {\n    const fetchContractData = async () => {\n      try {\n        const pancakeRabbitsContract = getPancakeRabbitContract();\n        const [canClaimArr, hasClaimedArr] = await multicall(rabbitmintingfarm, [{\n          address: RABBIT_MINTING_FARM_ADDRESS,\n          name: 'canClaim',\n          params: [account]\n        }, {\n          address: RABBIT_MINTING_FARM_ADDRESS,\n          name: 'hasClaimed',\n          params: [account]\n        }]);\n        const balanceOf = await pancakeRabbitsContract.methods.balanceOf(account).call();\n        const [canClaim] = canClaimArr;\n        const [hasClaimed] = hasClaimedArr;\n        let bunnyMap = {}; // If the \"balanceOf\" is greater than 0 then retrieve the tokenIds\n        // owned by the wallet, then the bunnyId's associated with the tokenIds\n\n        if (balanceOf > 0) {\n          const getTokenIdAndBunnyId = async index => {\n            try {\n              const tokenId = await pancakeRabbitsContract.methods.tokenOfOwnerByIndex(account, index).call();\n              const bunnyId = await pancakeRabbitsContract.methods.getBunnyId(tokenId).call();\n              return [parseInt(bunnyId, 10), parseInt(tokenId, 10)];\n            } catch (error) {\n              return null;\n            }\n          };\n\n          const tokenIdPromises = [];\n\n          for (let i = 0; i < balanceOf; i++) {\n            tokenIdPromises.push(getTokenIdAndBunnyId(i));\n          }\n\n          const tokenIdsOwnedByWallet = await Promise.all(tokenIdPromises); // While improbable a wallet can own more than one of the same bunny so the format is:\n          // { [bunnyId]: [array of tokenIds] }\n\n          bunnyMap = tokenIdsOwnedByWallet.reduce((accum, association) => {\n            if (!association) {\n              return accum;\n            }\n\n            const [bunnyId, tokenId] = association;\n            return { ...accum,\n              [bunnyId]: accum[bunnyId] ? [...accum[bunnyId], tokenId] : [tokenId]\n            };\n          }, {});\n        }\n\n        setState(prevState => ({ ...prevState,\n          isInitialized: true,\n          canClaim,\n          hasClaimed,\n          balanceOf,\n          bunnyMap\n        }));\n      } catch (error) {\n        console.error('an error occured', error);\n      }\n    };\n\n    if (account) {\n      fetchContractData();\n    }\n  }, [isInitialized, account, setState]);\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n    };\n  }, [isMounted]);\n  const canBurnNft = currentBlock <= state.endBlockNumber;\n\n  const getTokenIds = bunnyId => state.bunnyMap[bunnyId];\n  /**\r\n   * Allows consumers to re-fetch all data from the contract. Triggers the effects.\r\n   * For example when a transaction has been completed\r\n   */\n\n\n  const reInitialize = () => {\n    // Only attempt to re-initialize if the component is still mounted\n    // Transactions can take awhile so it is likely some users will navigate to another page\n    // before the transaction is finished\n    if (isMounted.current) {\n      setState(prevState => ({ ...prevState,\n        isInitialized: false\n      }));\n    }\n  };\n\n  return /*#__PURE__*/_jsxDEV(NftProviderContext.Provider, {\n    value: { ...state,\n      canBurnNft,\n      getTokenIds,\n      reInitialize\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 194,\n    columnNumber: 5\n  }, this);\n};\n\n_s(NftProvider, \"x0puUfNp+EQ6M25w+u+6DNJcZyQ=\", false, function () {\n  return [useWallet, useBlock];\n});\n\n_c = NftProvider;\nexport default NftProvider;\n\nvar _c;\n\n$RefreshReg$(_c, \"NftProvider\");","map":{"version":3,"sources":["/Users/ivopascoal/Desktop/Naughty/naughty_front/src/views/Nft/contexts/NftProvider.tsx"],"names":["React","createContext","useEffect","useRef","useState","useWallet","useBlock","rabbitmintingfarm","RABBIT_MINTING_FARM_ADDRESS","multicall","getPancakeRabbitContract","NftProviderContext","NftProvider","children","isMounted","state","setState","isInitialized","canClaim","hasClaimed","countBunniesBurnt","startBlockNumber","endBlockNumber","totalSupplyDistributed","currentDistributedSupply","balanceOf","bunnyMap","account","currentBlock","fetchContractData","startBlockNumberArr","endBlockNumberArr","countBunniesBurntArr","totalSupplyDistributedArr","currentDistributedSupplyArr","address","name","prevState","toNumber","error","console","pancakeRabbitsContract","canClaimArr","hasClaimedArr","params","methods","call","getTokenIdAndBunnyId","index","tokenId","tokenOfOwnerByIndex","bunnyId","getBunnyId","parseInt","tokenIdPromises","i","push","tokenIdsOwnedByWallet","Promise","all","reduce","accum","association","current","canBurnNft","getTokenIds","reInitialize"],"mappings":"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","sourcesContent":["import React, { createContext, ReactNode, useEffect, useRef, useState } from 'react'\r\nimport BigNumber from 'bignumber.js'\r\nimport { useWallet } from '@binance-chain/bsc-use-wallet'\r\nimport useBlock from 'hooks/useBlock'\r\nimport rabbitmintingfarm from 'config/abi/rabbitmintingfarm.json'\r\nimport { RABBIT_MINTING_FARM_ADDRESS } from 'config/constants/nfts'\r\nimport multicall from 'utils/multicall'\r\nimport { getPancakeRabbitContract } from '../utils/contracts'\r\n\r\ninterface NftProviderProps {\r\n  children: ReactNode\r\n}\r\n\r\ntype BunnyMap = {\r\n  [key: number]: number[]\r\n}\r\n\r\ntype State = {\r\n  isInitialized: boolean\r\n  canClaim: boolean\r\n  hasClaimed: boolean\r\n  countBunniesBurnt: number\r\n  endBlockNumber: number\r\n  startBlockNumber: number\r\n  totalSupplyDistributed: number\r\n  currentDistributedSupply: number\r\n  balanceOf: number\r\n  bunnyMap: BunnyMap\r\n}\r\n\r\ntype Context = {\r\n  canBurnNft: boolean\r\n  getTokenIds: (bunnyId: number) => number[]\r\n  reInitialize: () => void\r\n} & State\r\n\r\nexport const NftProviderContext = createContext<Context | null>(null)\r\n\r\nconst NftProvider: React.FC<NftProviderProps> = ({ children }) => {\r\n  const isMounted = useRef(true)\r\n  const [state, setState] = useState<State>({\r\n    isInitialized: false,\r\n    canClaim: false,\r\n    hasClaimed: false,\r\n    countBunniesBurnt: 0,\r\n    startBlockNumber: 0,\r\n    endBlockNumber: 0,\r\n    totalSupplyDistributed: 0,\r\n    currentDistributedSupply: 0,\r\n    balanceOf: 0,\r\n    bunnyMap: {},\r\n  })\r\n  const { account } = useWallet()\r\n  const currentBlock = useBlock()\r\n\r\n  const { isInitialized } = state\r\n\r\n  // Static data\r\n  useEffect(() => {\r\n    const fetchContractData = async () => {\r\n      try {\r\n        const [\r\n          startBlockNumberArr,\r\n          endBlockNumberArr,\r\n          countBunniesBurntArr,\r\n          totalSupplyDistributedArr,\r\n          currentDistributedSupplyArr,\r\n        ] = await multicall(rabbitmintingfarm, [\r\n          { address: RABBIT_MINTING_FARM_ADDRESS, name: 'startBlockNumber' },\r\n          { address: RABBIT_MINTING_FARM_ADDRESS, name: 'endBlockNumber' },\r\n          { address: RABBIT_MINTING_FARM_ADDRESS, name: 'countBunniesBurnt' },\r\n          { address: RABBIT_MINTING_FARM_ADDRESS, name: 'totalSupplyDistributed' },\r\n          { address: RABBIT_MINTING_FARM_ADDRESS, name: 'currentDistributedSupply' },\r\n        ])\r\n\r\n        // TODO: Figure out why these are coming back as arrays\r\n        const [startBlockNumber]: [BigNumber] = startBlockNumberArr\r\n        const [endBlockNumber]: [BigNumber] = endBlockNumberArr\r\n        const [countBunniesBurnt]: [BigNumber] = countBunniesBurntArr\r\n        const [totalSupplyDistributed]: [BigNumber] = totalSupplyDistributedArr\r\n        const [currentDistributedSupply]: [BigNumber] = currentDistributedSupplyArr\r\n\r\n        setState((prevState) => ({\r\n          ...prevState,\r\n          isInitialized: true,\r\n          countBunniesBurnt: countBunniesBurnt.toNumber(),\r\n          startBlockNumber: startBlockNumber.toNumber(),\r\n          endBlockNumber: endBlockNumber.toNumber(),\r\n          currentDistributedSupply: currentDistributedSupply.toNumber(),\r\n          totalSupplyDistributed: totalSupplyDistributed.toNumber(),\r\n        }))\r\n      } catch (error) {\r\n        console.error('an error occured', error)\r\n      }\r\n    }\r\n\r\n    fetchContractData()\r\n  }, [isInitialized, setState])\r\n\r\n  // Data from the contract that needs an account\r\n  useEffect(() => {\r\n    const fetchContractData = async () => {\r\n      try {\r\n        const pancakeRabbitsContract = getPancakeRabbitContract()\r\n        const [canClaimArr, hasClaimedArr] = await multicall(rabbitmintingfarm, [\r\n          { address: RABBIT_MINTING_FARM_ADDRESS, name: 'canClaim', params: [account] },\r\n          { address: RABBIT_MINTING_FARM_ADDRESS, name: 'hasClaimed', params: [account] },\r\n        ])\r\n        const balanceOf = await pancakeRabbitsContract.methods.balanceOf(account).call()\r\n        const [canClaim]: [boolean] = canClaimArr\r\n        const [hasClaimed]: [boolean] = hasClaimedArr\r\n\r\n        let bunnyMap: BunnyMap = {}\r\n\r\n        // If the \"balanceOf\" is greater than 0 then retrieve the tokenIds\r\n        // owned by the wallet, then the bunnyId's associated with the tokenIds\r\n        if (balanceOf > 0) {\r\n          const getTokenIdAndBunnyId = async (index: number) => {\r\n            try {\r\n              const tokenId = await pancakeRabbitsContract.methods.tokenOfOwnerByIndex(account, index).call()\r\n              const bunnyId = await pancakeRabbitsContract.methods.getBunnyId(tokenId).call()\r\n\r\n              return [parseInt(bunnyId, 10), parseInt(tokenId, 10)]\r\n            } catch (error) {\r\n              return null\r\n            }\r\n          }\r\n\r\n          const tokenIdPromises = []\r\n\r\n          for (let i = 0; i < balanceOf; i++) {\r\n            tokenIdPromises.push(getTokenIdAndBunnyId(i))\r\n          }\r\n\r\n          const tokenIdsOwnedByWallet = await Promise.all(tokenIdPromises)\r\n\r\n          // While improbable a wallet can own more than one of the same bunny so the format is:\r\n          // { [bunnyId]: [array of tokenIds] }\r\n          bunnyMap = tokenIdsOwnedByWallet.reduce((accum, association) => {\r\n            if (!association) {\r\n              return accum\r\n            }\r\n\r\n            const [bunnyId, tokenId] = association\r\n\r\n            return {\r\n              ...accum,\r\n              [bunnyId]: accum[bunnyId] ? [...accum[bunnyId], tokenId] : [tokenId],\r\n            }\r\n          }, {})\r\n        }\r\n\r\n        setState((prevState) => ({\r\n          ...prevState,\r\n          isInitialized: true,\r\n          canClaim,\r\n          hasClaimed,\r\n          balanceOf,\r\n          bunnyMap,\r\n        }))\r\n      } catch (error) {\r\n        console.error('an error occured', error)\r\n      }\r\n    }\r\n\r\n    if (account) {\r\n      fetchContractData()\r\n    }\r\n  }, [isInitialized, account, setState])\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      isMounted.current = false\r\n    }\r\n  }, [isMounted])\r\n\r\n  const canBurnNft = currentBlock <= state.endBlockNumber\r\n  const getTokenIds = (bunnyId: number) => state.bunnyMap[bunnyId]\r\n\r\n  /**\r\n   * Allows consumers to re-fetch all data from the contract. Triggers the effects.\r\n   * For example when a transaction has been completed\r\n   */\r\n  const reInitialize = () => {\r\n    // Only attempt to re-initialize if the component is still mounted\r\n    // Transactions can take awhile so it is likely some users will navigate to another page\r\n    // before the transaction is finished\r\n    if (isMounted.current) {\r\n      setState((prevState) => ({ ...prevState, isInitialized: false }))\r\n    }\r\n  }\r\n\r\n  return (\r\n    <NftProviderContext.Provider value={{ ...state, canBurnNft, getTokenIds, reInitialize }}>\r\n      {children}\r\n    </NftProviderContext.Provider>\r\n  )\r\n}\r\n\r\nexport default NftProvider\r\n"]},"metadata":{},"sourceType":"module"}